+-------------------+
| concatenation.txt |
+-------------------+
(!): 1 blank lines


+-------------------------------------------------+
| Tests/ConstructorsTests/ConstructorsTests.swift |
+-------------------------------------------------+
import Testing
@testable import Constructors

@Test func example() async throws {
    // Write your test here and use APIs like `#expect(...)` to check expected conditions.
}

(!): 1 blank lines


+------------------------------------------------------+
| Tests/ConstructorsTests/html/html-builder-test.swift |
+------------------------------------------------------+
// import XCTest
// @testable import Constructors
import Testing
@testable import Constructors

@Suite("HTML DSL")
struct HTMLDSLTests {
// final class HTMLDSLTests: XCTestCase {
    var HMFooter: HTMLFragment {
        [
            HTML.div(.class(["footer"])) {
                HTML.text("Hondenmeesters | Ondersteuning bij hondengedrag"); HTML.br()
                HTML.text("Marterkoog 7B"); HTML.br()
                HTML.text("1822BK Alkmaar"); HTML.br(); HTML.br()
                HTML.text("Telefoon: +31 6 23 62 13 90")
            }
        ]
    }

    public struct TestModel: Equatable {
        public let heading: String
        public let subheading: String
        public let details: String
        public init(_ heading: String, _ subheading: String, _ details: String) {
            self.heading = heading
            self.subheading = subheading
            self.details = details
        }
    }

    let tests: [TestModel] = {
        var r: [TestModel] = []
        for i in 0..<4 {
            let x = i + 1
            r.append(
                .init(
                    "Appointment #\(x)",
                    "Here we do \(x * 2) things",
                    "Address for number \(x)",
                )
            )
        }
        return r
    }()

    var testComp: HTMLFragment {
        var comps: [any HTMLNode] = []
        for i in tests {
            comps.append(contentsOf: [
                HTML.div(.class(["fictitious-class"])) {
                    HTML.text(i.heading); HTML.br()
                    HTML.text(i.subheading); HTML.br()
                    HTML.text(i.details)
                },
                HTML.br()
            ])
        }
        return comps
    }

    // prepping for templater/v1 usage
    @Test("basicDocumentRendersAndEscapes")
    func basicDocumentRendersAndEscapes() throws {
        let doc = HTMLDocument.basic(
            lang: "nl",
            title: "Bevestiging",
            stylesheets: ["/assets/mail.css"],
            inlineStyle: "body{font-family:-apple-system,Segoe UI,Arial,sans-serif}"
        ) {
            HTML.div(.class(["container"])) {
                HTML.img(src: "/img/logo.png", alt: "Hondenmeesters", .class(["logo"]))
                HTML.hr()
                HTML.p {
                    HTML.text("Beste ")
                    HTML.text("{{name}}")        // safe text
                    HTML.raw("<br>")             // deliberate raw to test mixing
                }
                HTML.ul {
                    for i in 1...3 {
                        HTML.li { HTML.text("punt \(i)") }
                    }
                }
                HTML.p(.aria("live", "polite")) {
                    HTML.a("https://hondenmeesters.nl/support") { HTML.text("Geef jouw feedback") }
                }
                HTML.br() // void
                HTML.table(.class(["table","table-compact"])) {
                    HTML.thead {
                        HTML.tr {
                            HTML.th { HTML.text("Kolom A") }
                            HTML.th { HTML.text("Kolom B") }
                        }
                    }
                    HTML.tbody {
                        HTML.tr {
                            HTML.td { HTML.text("<escaped> & \"quotes\"") } // ensure escaping
                            HTML.td { HTML.text("✓ boolean attrs next") }
                        }
                    }
                }
                // Boolean attribute example: disabled button (presence implies true)
                HTML.el("button", HTMLAttribute.bool("disabled", true)) { HTML.text("Versturen") }

                HMFooter
                testComp
            }
        }

        // compact vs pretty render
        let prettyHTML  = doc.render(pretty: true,  indentStep: 4)
        let compactHTML = doc.render(pretty: false, indentStep: 0)

        // head/doc bits
        #expect(prettyHTML.contains(#"<html lang="nl">"#))
        #expect(prettyHTML.contains("body{font-family:-apple-system"))

        #expect(compactHTML.contains("<title>Bevestiging</title>"))
        #expect(compactHTML.contains(#"<link href="/assets/mail.css" rel="stylesheet">"#))

        // void elements
        #expect(prettyHTML.contains("<br>"))
        #expect(prettyHTML.contains("<hr>"))
        #expect(prettyHTML.contains(#"<img class="logo" src="/img/logo.png" alt="Hondenmeesters">"#))

        // escaping
        #expect(prettyHTML.contains("&lt;escaped&gt; &amp; &quot;quotes&quot;"))

        // boolean attribute
        #expect(compactHTML.contains("<button disabled>Versturen</button>"))

        // footer
        #expect(prettyHTML.contains("Hondenmeesters | Ondersteuning bij hondengedrag"))
        #expect(prettyHTML.contains("Marterkoog 7B"))
        #expect(prettyHTML.contains("1822BK Alkmaar"))
        #expect(prettyHTML.contains("Telefoon: +31 6 23 62 13 90")) 

        for x in 1...4 {
            #expect(prettyHTML.contains("Appointment #\(x)"))
            #expect(prettyHTML.contains("Here we do \(x * 2) things"))
            #expect(prettyHTML.contains("Address for number \(x)"))
        }
    }

    @Test
    func bodyOnlyConvenience() {
        let bodyOnly = HTML.body {
            HTML.p { HTML.text("Body only mode") }
        }
        let bodyDoc = HTMLDocument(children: [bodyOnly]).render(pretty: false)
        #expect(bodyDoc.contains("<p>Body only mode</p>"))
        #expect(bodyDoc.contains("<body>"))
    }
}

(!): 1 blank lines


+------------------+
| Package.resolved |
+------------------+
{
  "originHash" : "13cf52bff01bf4bfc1057ebca776d91d69fb62d8a99ef5bcb600f8c400d18398",
  "pins" : [
    {
      "identity" : "swift-syntax",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/swiftlang/swift-syntax.git",
      "state" : {
        "revision" : "4799286537280063c85a32f09884cfbca301b1a1",
        "version" : "602.0.0"
      }
    },
    {
      "identity" : "swift-testing",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/swiftlang/swift-testing",
      "state" : {
        "revision" : "3fdabe5392108d874abae1c1e58e1328ab46f681",
        "version" : "6.2.0"
      }
    }
  ],
  "version" : 3
}

(!): 1 blank lines


+---------------+
| Package.swift |
+---------------+
// swift-tools-version: 6.2
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "Constructors",
    platforms: [
        .macOS(.v13)
    ],
    products: [
        .library(
            name: "Constructors",
            targets: ["Constructors"]
        ),
    ],
    dependencies: [
        .package(url: "https://github.com/swiftlang/swift-testing.git", from: "6.2.0")
    ],
    targets: [
        .target(
            name: "Constructors"
        ),
        .testTarget(
            name: "ConstructorsTests",
            dependencies: [
                "Constructors",
                .product(name: "Testing", package: "swift-testing"),
            ]
        ),
    ]
)

(!): 1 blank lines


+----------------------------------------------------------+
| Sources/Constructors/html/constants/html-void-tags.swift |
+----------------------------------------------------------+
import Foundation

public enum HTMLSpec {
    public static let void: Set<String> = [
        "area","base","br","col","embed","hr","img","input","link",
        "meta","param","source","track","wbr"
    ]

    @inline(__always) public static func isVoid(_ tag: String) -> Bool { void.contains(tag) }
}

@available(*, message: "Replaced by HTMLSpec.void / .isVoid")
public let HTMLVoidTags: Set<String> = [
    "area","base","br","col","embed","hr","img","input","link","meta","param","source","track","wbr"
]

(!): 1 blank lines


+-----------------------------------------------------+
| Sources/Constructors/html/models/html-newline.swift |
+-----------------------------------------------------+
import Foundation

public struct HTMLNewline: HTMLNode {
    public let count: Int
    public init(_ count: Int = 1) { self.count = count }

    public func render(options: HTMLRenderOptions, indent: Int) -> String {
        // Only meaningful in pretty mode; keep minified output tight
        guard options.pretty else { return "" }
        return String(repeating: "\n", count: count)
    }
}

(!): 1 blank lines


+-----------------------------------------------------+
| Sources/Constructors/html/models/html-element.swift |
+-----------------------------------------------------+
import Foundation

public struct HTMLElement: HTMLNode {
    public let tag: String
    public var attrs: HTMLAttribute
    public var children: [any HTMLNode]
    public var selfClosing: Bool // NEW

    public init(
        _ tag: String,
        attrs: HTMLAttribute = HTMLAttribute(),
        children: [any HTMLNode] = [],
        selfClosing: Bool = false
    ) {
        self.tag = tag
        self.attrs = attrs
        self.children = children
        self.selfClosing = selfClosing
    }

    // public func render(pretty: Bool, indent: Int, indentStep: Int) -> String {
    //     let pad = pretty ? String(repeating: " ", count: indent) : ""
    //     let nl  = pretty ? "\n" : ""
    //     let attrStr = attrs.render()
    //     let open = attrStr.isEmpty ? "<\(tag)>" : "<\(tag) \(attrStr)>"

    //     if HTMLVoidTags.contains(tag) {
    //         // Void elements: <meta ...>, <img ...>, <br>, <hr>, <input>, <link>, etc.
    //         return pretty ? pad + open + nl : open
    //     }

    //     if children.isEmpty {
    //         // <div></div> or <span></span>
    //         if selfClosing && !HTMLVoidTags.contains(tag) {
    //             return pretty ? pad + open.dropLast() + "/>\n" : open.dropLast() + "/>"
    //         }

    //         return pretty ? pad + open + "</\(tag)>" + nl : open + "</\(tag)>"
    //     }

    //     if pretty {
    //         let inner = children.map { $0.render(pretty: true, indent: indent + indentStep, indentStep: indentStep) }.joined()
    //         return "\(pad)\(open)\n\(inner)\(pad)</\(tag)>\n"
    //     } else {
    //         let inner = children.map { $0.render(pretty: false, indent: 0, indentStep: indentStep) }.joined()
    //         return "\(open)\(inner)</\(tag)>"
    //     }
    // }

//     public func render(pretty: Bool, indent: Int, indentStep: Int) -> String {
//         let pad = pretty ? String(repeating: " ", count: indent) : ""
//         let nl  = pretty ? "\n" : ""
//         let attrStr = attrs.render()
//         let open = attrStr.isEmpty ? "<\(tag)>" : "<\(tag) \(attrStr)>"

//         // HTML void elements
//         if HTMLVoidTags.contains(tag) {
//             return pretty ? pad + open + nl : open
//         }

//         // No children
//         if children.isEmpty {
//             if selfClosing {
//                 let selfClosed = String(open.dropLast()) + "/>"
//                 return pretty ? pad + selfClosed + nl : selfClosed
//             }
//             return pretty ? pad + open + "</\(tag)>" + nl : open + "</\(tag)>"
//         }

//         // With children
//         if pretty {
//             let inner = children.map { $0.render(pretty: true, indent: indent + indentStep, indentStep: indentStep) }.joined()
//             return "\(pad)\(open)\n\(inner)\(pad)</\(tag)>\n"
//         } else {
//             let inner = children.map { $0.render(pretty: false, indent: indent, indentStep: indentStep) }.joined()
//             return "\(open)\(inner)</\(tag)>"
//         }
//     }

    // Helper to render empty nodes (void or selfClosing)
    @inline(__always)
    private func renderEmpty(open: String, indent: Int, options: HTMLRenderOptions) -> String {
        let pad = options.pretty ? String(repeating: " ", count: indent) : ""
        let nl  = options.pretty ? "\n" : ""

        if HTMLSpec.isVoid(tag) {
            return options.pretty ? pad + open + nl : open
        }
        if selfClosing {
            let selfClosed = String(open.dropLast()) + "/>"
            return options.pretty ? pad + selfClosed + nl : selfClosed
        }
        // Not void and not selfClosing → caller will append closing tag
        return "" // signal “not handled”
    }

    public func render(options: HTMLRenderOptions, indent: Int) -> String {
        let pad = options.pretty ? String(repeating: " ", count: indent) : ""
        let nl  = options.pretty ? "\n" : ""

        let attrStr = attrs.render(order: options.attributeOrder)
        let open = attrStr.isEmpty ? "<\(tag)>" : "<\(tag) \(attrStr)>"

        // Empty cases first
        if children.isEmpty {
            // try void/selfClosing paths
            let empty = renderEmpty(open: open, indent: indent, options: options)
            if !empty.isEmpty { return empty }
            // fallback: explicit open/close
            return options.pretty ? pad + open + "</\(tag)>" + nl : open + "</\(tag)>"
        }

        // With children
        if options.pretty {
            let inner = children.map { $0.render(options: options, indent: indent + options.indentStep) }.joined()
            return "\(pad)\(open)\n\(inner)\(pad)</\(tag)>\n"
        } else {
            let inner = children.map { $0.render(options: options, indent: indent) }.joined()
            return "\(open)\(inner)</\(tag)>"
        }
    }

    public func render(pretty: Bool, indent: Int, indentStep: Int) -> String {
        let legacy = HTMLRenderOptions(
            pretty: pretty,
            indentStep: indentStep,
            attributeOrder: .ranked,
            ensureTrailingNewline: false
        )

        return render(options: legacy, indent: indent)
    }

}

(!): 1 blank lines


+------------------------------------------------------------+
| Sources/Constructors/html/models/html-render-options.swift |
+------------------------------------------------------------+
import Foundation

public struct HTMLRenderOptions: Sendable {
    public var pretty: Bool
    public var indentStep: Int
    public var attributeOrder: HTMLAttributeOrder
    public var ensureTrailingNewline: Bool

    public init(
        pretty: Bool = true,
        indentStep: Int = 4,
        attributeOrder: HTMLAttributeOrder = .preserve,
        ensureTrailingNewline: Bool = true
    ) {
        self.pretty = pretty
        self.indentStep = indentStep
        self.attributeOrder = attributeOrder
        self.ensureTrailingNewline = ensureTrailingNewline
    }
}

(!): 1 blank lines


+-----------------------------------------------------+
| Sources/Constructors/html/models/html-comment.swift |
+-----------------------------------------------------+
import Foundation

public struct HTMLComment: HTMLNode {
    public let text: String

    public func render(options: HTMLRenderOptions, indent: Int) -> String {
        // let space = " "
        // let indentation = String(repeating: space, count: (indent * options.indentStep))
        let indentation = String(repeating: " ", count: indent)
        let pad = options.pretty ? indentation : ""
        let newline  = options.pretty ? "\n" : ""

        return "\(pad)<!-- \(text) -->\(newline)"
    }
}

(!): 1 blank lines


+--------------------------------------------------+
| Sources/Constructors/html/models/html-text.swift |
+--------------------------------------------------+
import Foundation

public struct HTMLText: HTMLNode {
    public let text: String

    public init(_ text: String) { self.text = text }

    @available(*, message: "deprecated")
    public func render(pretty: Bool, indent: Int, indentStep: Int) -> String {
        let escaped = htmlEscape(text)
        guard pretty else { return escaped }
        let pad = String(repeating: " ", count: indent)
        return escaped
        .split(separator: "\n", omittingEmptySubsequences: false)
        .map { pad + String($0) }
        .joined(separator: "\n") + "\n"
    }

    public func render(options: HTMLRenderOptions, indent: Int) -> String {
        let escaped = htmlEscape(text)
        guard options.pretty else { return escaped }
        // let space = " "
        // let indentation = String(repeating: space, count: (indent * options.indentStep))
        let pad = String(repeating: " ", count: indent)

        return escaped
            .split(separator: "\n", omittingEmptySubsequences: false)
            .map { pad + String($0) }
            .joined(separator: "\n") + "\n"
    }
}

(!): 1 blank lines


+------------------------------------------------------+
| Sources/Constructors/html/models/html-document.swift |
+------------------------------------------------------+
import Foundation

public struct HTMLDocument: Sendable {
    public var children: [any HTMLNode]
    public init(children: [any HTMLNode]) { self.children = children }

    // @available(*, message: "Deprecated, instead of 'indentStep', use 'options: HTMLRenderOptions()'")
    // public func render(pretty: Bool = true, indentStep: Int = 4) -> String {
    //     let body = children.map { $0.render(pretty: pretty, indent: 0, indentStep: indentStep) }.joined()
    //     return "<!DOCTYPE html>\n" + body
    // }

    // @available(*, message: "Deprecated, use 'options: HTMLRenderOptions()'")
    // public func render(options: HTMLRenderOptions = .init(), pretty: Bool = true) -> String {
    //     let body = children.map {
    //         $0.render(pretty: pretty, indent: 0, indentStep: options.indentStep)
    //     }.joined()

    //     var out = "<!DOCTYPE html>\n" + body
    //     if options.ensureTrailingNewline, !out.hasSuffix("\n") { out.append("\n") }
    //     return out
    // }

    public func render(options: HTMLRenderOptions = .init()) -> String {
        let body = children.map { $0.render(options: options, indent: 0) }.joined()
        var out = "<!DOCTYPE html>\n" + body
        if options.ensureTrailingNewline, !out.hasSuffix("\n") { out.append("\n") }
        return out
    }

    // @available(*, message: "deprecated")
    // public static func basic(
    //     lang: String? = nil,
    //     title: String? = nil,
    //     stylesheets: [String] = [],
    //     inlineStyle: String? = nil,
    //     @HTMLBuilder body: () -> [any HTMLNode]
    // ) -> HTMLDocument {
    //     HTML.document {
    //         HTML.html(lang.map { ["lang": $0] } ?? HTMLAttribute()) {
    //             HTML.head {
    //                 HTML.meta(["charset": "UTF-8"])
    //                 if let title = title { HTML.title(title) }
    //                 for href in stylesheets { HTML.linkStylesheet(href: href) }
    //                 if let css = inlineStyle { HTML.style(css) }
    //             }
    //             HTML.body {
    //                 body()
    //             }
    //         }
    //     }
    // }

    /// Minimal convenience page builder (kept small on purpose).
    /// Uses MetaSpec/LinkSpec instead of legacy helpers.
    public static func basic(
        lang: String? = nil,
        title: String? = nil,
        stylesheets: [String] = [],
        inlineStyle: String? = nil,
        @HTMLBuilder body: () -> [any HTMLNode]
    ) -> HTMLDocument {
        HTML.document {
            HTML.html(lang.map { ["lang": $0] } ?? HTMLAttribute()) {
                HTML.head {
                    // <meta charset="UTF-8">
                    HTML.meta(.charset())

                    if let title {
                        HTML.title(title)
                    }

                    // <link rel="stylesheet" ...> (in author order)
                    for href in stylesheets {
                        HTML.link(.stylesheet(href: href))
                    }

                    // Inline <style> … </style>
                    if let css = inlineStyle {
                        HTML.style(css)
                    }
                }
                HTML.body {
                    body()
                }
            }
        }
    }
}

(!): 1 blank lines


+------------------------------------------------------+
| Sources/Constructors/html/models/html-fragment.swift |
+------------------------------------------------------+
import Foundation

public typealias HTMLFragment = [any HTMLNode]

(!): 1 blank lines


+-------------------------------------------------+
| Sources/Constructors/html/models/html-raw.swift |
+-------------------------------------------------+
import Foundation

public struct HTMLRaw: HTMLNode {
    public let html: String

    public init(_ html: String) { self.html = html }

    @available(*, message: "deprecated")
    public func render(pretty: Bool, indent: Int, indentStep: Int) -> String {
        guard pretty else { return html }
        let pad = String(repeating: " ", count: indent)
        return html
        .split(separator: "\n", omittingEmptySubsequences: false)
        .map { pad + String($0) }
        .joined(separator: "\n") + "\n"
    }

    public func render(options: HTMLRenderOptions, indent: Int) -> String {
        guard options.pretty else { return html }
        // let space = " "
        // let indentation = String(repeating: space, count: (indent * options.indentStep))

        let pad = String(repeating: " ", count: indent)

        return html
            .split(separator: "\n", omittingEmptySubsequences: false)
            .map { pad + String($0) }
            .joined(separator: "\n") + "\n"
    }
}

(!): 1 blank lines


+-------------------------------------------------------------+
| Sources/Constructors/html/models/html-attribute-order.swift |
+-------------------------------------------------------------+
import Foundation

public enum HTMLAttributeOrder: Sendable {
    case preserve
    case ranked
    case custom(@Sendable (String, String) -> Bool)
}

(!): 1 blank lines


+-------------------------------------------------------+
| Sources/Constructors/html/models/html-attribute.swift |
+-------------------------------------------------------+
import Foundation

public struct HTMLAttribute: ExpressibleByDictionaryLiteral, Sendable {
    private var storage: [(String, String?)] = []

    public init() {}

    public init(dictionaryLiteral elements: (String, String)...) {
        self.storage = elements.map { ($0.0, $0.1) }
    }

    public static func id(_ value: String) -> HTMLAttribute { ["id": value] }
    public static func `class`(_ classes: [String]) -> HTMLAttribute { ["class": classes.joined(separator: " ")] }
    public static func data(_ key: String, _ value: String) -> HTMLAttribute { ["data-\(key)": value] }
    public static func aria(_ key: String, _ value: String) -> HTMLAttribute { ["aria-\(key)": value] }
    public static func bool(_ key: String, _ enabled: Bool) -> HTMLAttribute {
        var a = HTMLAttribute()
        if enabled { a.storage.append((key, nil)) }
        return a
    }

    public mutating func merge(_ other: HTMLAttribute) {
        storage.append(contentsOf: other.storage)
    }

    // public func render() -> String {
    //     guard !storage.isEmpty else { return "" }

    //     @inline(__always)
    //     func keyRank(_ k: String) -> (Int, String) {
    //         // 0 = highest priority, larger = lower
    //         switch k {
    //         case "id": return (0, k)
    //         case "class": return (1, k)
    //         case "src": return (2, k)
    //         case "href": return (3, k)
    //         case "alt": return (4, k)
    //         case "type": return (5, k)
    //         case "name": return (6, k)
    //         case "value": return (7, k)
    //         case "width": return (8, k)
    //         case "height": return (9, k)
    //         case "style": return (10, k)
    //         default:
    //             if k.hasPrefix("data-") { return (20, k) }
    //             if k.hasPrefix("aria-") { return (30, k) }
    //             return (40, k)
    //         }
    //     }

    //     let ordered = storage.sorted { (a, b) in
    //         let (ra, sa) = keyRank(a.0)
    //         let (rb, sb) = keyRank(b.0)
    //         return (ra, sa) < (rb, sb)
    //     }

    //     var parts: [String] = []
    //     parts.reserveCapacity(ordered.count)
    //     for (k, v) in ordered {
    //         if let v {
    //             parts.append("\(k)=\"\(htmlEscape(v))\"")
    //         } else {
    //             parts.append(k)
    //         }
    //     }
    //     return parts.joined(separator: " ")
    // }

    /// Back-compat: existing API keeps "ranked" as default behavior.
    public func render() -> String {
        render(order: .ranked)
    }

    /// Order-aware rendering. `.ranked` preserves the old implementation.
    public func render(order: HTMLAttributeOrder) -> String {
        guard !storage.isEmpty else { return "" }

        let ordered: [(String, String?)]

        switch order {
        case .preserve:
            ordered = storage

        case .ranked:
            // Original behavior (unchanged)
            @inline(__always)
            func keyRank(_ k: String) -> (Int, String) {
                // 0 = highest priority, larger = lower
                switch k {
                case "id": return (0, k)
                case "class": return (1, k)
                case "src": return (2, k)
                case "href": return (3, k)
                case "alt": return (4, k)
                case "type": return (5, k)
                case "name": return (6, k)
                case "value": return (7, k)
                case "width": return (8, k)
                case "height": return (9, k)
                case "style": return (10, k)
                default:
                    if k.hasPrefix("data-") { return (20, k) }
                    if k.hasPrefix("aria-") { return (30, k) }
                    return (40, k)
                }
            }

            ordered = storage.sorted { (a, b) in
                let (ra, sa) = keyRank(a.0)
                let (rb, sb) = keyRank(b.0)
                return (ra, sa) < (rb, sb)
            }

        case .custom(let cmp):
            // Deterministic: if keys are equal, keep insertion order.
            let enumerated = Array(storage.enumerated())
            let sorted = enumerated.sorted { lhs, rhs in
                let lk = lhs.element.0
                let rk = rhs.element.0
                if lk == rk { return lhs.offset < rhs.offset }
                return cmp(lk, rk)
            }
            ordered = sorted.map { $0.element }
        }

        var parts: [String] = []
        parts.reserveCapacity(ordered.count)
        for (k, v) in ordered {
            if let v {
                parts.append("\(k)=\"\(htmlEscape(v))\"")
            } else {
                parts.append(k)
            }
        }
        return parts.joined(separator: " ")
    }

    public static func `class`(_ s: String) -> HTMLAttribute { ["class": s] }
}

(!): 1 blank lines


+-------------------------------------------------------------+
| Sources/Constructors/html/protocol/html-node-protocol.swift |
+-------------------------------------------------------------+
import Foundation

public protocol HTMLNode: Sendable, HTMLCommentable {
    @available(*, deprecated, message: "Use the options-aware render(_:indent:indentStep:options:) overload.")
    func render(pretty: Bool, indent: Int, indentStep: Int) -> String

    func render(options: HTMLRenderOptions, indent: Int) -> String
}

public extension HTMLNode {
    func render(pretty: Bool, indent: Int, indentStep: Int) -> String {
        let opts = HTMLRenderOptions(
            pretty: pretty,
            indentStep: indentStep,
            attributeOrder: .ranked,
            ensureTrailingNewline: false
        )

        return render(options: opts, indent: indent)
    }

    func commented(
        options: HTMLRenderOptions = .init(),
        indent: Int = 0
    ) -> any HTMLNode {
        let rendered = self.render(options: options, indent: indent)
            .trimmingSingleTrailingNewline()
        return HTML.comment(sanitizeForHtmlComment(rendered))
    }
}

(!): 1 blank lines


+----------------------------------------------------+
| Sources/Constructors/html/funcs/html-builder.swift |
+----------------------------------------------------+
import Foundation

@resultBuilder
public enum HTMLBuilder: Sendable {
    public static func buildBlock(_ parts: [any HTMLNode]...) -> [any HTMLNode] {
        parts.flatMap { $0 }
    }
    public static func buildArray(_ parts: [[any HTMLNode]]) -> [any HTMLNode] { parts.flatMap { $0 } }
    public static func buildEither(first: [any HTMLNode]) -> [any HTMLNode] { first }
    public static func buildEither(second: [any HTMLNode]) -> [any HTMLNode] { second }
    public static func buildOptional(_ part: [any HTMLNode]?) -> [any HTMLNode] { part ?? [] }
    public static func buildExpression(_ node: any HTMLNode) -> [any HTMLNode] { [node] }
    public static func buildExpression(_ nodes: [any HTMLNode]) -> [any HTMLNode] { nodes }
    public static func buildExpression(_ text: String) -> [any HTMLNode] { [HTMLText(text)] }
    public static func buildLimitedAvailability(_ part: [any HTMLNode]) -> [any HTMLNode] { part }
}

@resultBuilder
public enum HTMLAttrBuilder {
    public static func buildBlock(_ parts: HTMLAttribute...) -> HTMLAttribute {
        var out = HTMLAttribute(); parts.forEach { out.merge($0) }; return out
    }
    public static func buildExpression(_ part: HTMLAttribute) -> HTMLAttribute { part }
}

public extension HTML {
    static func attrs(@HTMLAttrBuilder _ c: () -> HTMLAttribute) -> HTMLAttribute { c() }
}

(!): 1 blank lines


+--------------------------------------------------------+
| Sources/Constructors/html/funcs/html-commentable.swift |
+--------------------------------------------------------+
import Foundation

public protocol HTMLCommentable {
    func commented(
        options: HTMLRenderOptions,
        indent: Int
    ) -> any HTMLNode
}

public extension HTMLCommentable {
    func commented(
        node: any HTMLNode,
        options: HTMLRenderOptions = .init(),
        indent: Int = 0
    ) -> any HTMLNode {
        let rendered = node.render(options: options, indent: indent)
            .trimmingSingleTrailingNewline()
        return HTML.comment(sanitizeForHtmlComment(rendered))
    }
}

(!): 1 blank lines


+---------------------------------------------------+
| Sources/Constructors/html/funcs/html-escape.swift |
+---------------------------------------------------+
import Foundation

@inline(__always)
public func htmlEscape(_ s: String) -> String {
    var out = ""
    out.reserveCapacity(s.count + s.count/8)
    for ch in s {
        switch ch {
        case "&":  out += "&amp;"
        case "<":  out += "&lt;"
        case ">":  out += "&gt;"
        case "\"": out += "&quot;"
        case "'":  out += "&#39;"
        default:   out.append(ch)
        }
    }
    return out
}

(!): 1 blank lines


+------------------------------------------------------+
| Sources/Constructors/html/funcs/html-commented.swift |
+------------------------------------------------------+
import Foundation

@inline(__always)
public func sanitizeForHtmlComment(_ s: String) -> String {
    // HTML comments must not contain "--" anywhere.
    // Replace with an em dash to keep it visibly similar but valid.
    s.replacingOccurrences(of: "--", with: "—")
}

public extension String {
    func trimmingSingleTrailingNewline() -> String {
        guard last == "\n" else { return self }
        return String(dropLast(1))
    }
}

public extension HTML {
    /// Renders `node` with the given options and wraps the result in an HTML comment.
    /// - Parameters:
    ///   - node: Any HTMLNode to be commented out.
    ///   - options: Render options (pretty/indent/order). Defaults to your global defaults.
    ///   - indent: Starting indent (spaces) for the comment line(s).
    /// - Returns: `<!-- ...render(node)... -->`
    static func commented(
        _ node: any HTMLNode,
        options: HTMLRenderOptions = .init(),
        indent: Int = 0
    ) -> any HTMLNode {
        let rendered = node.render(options: options, indent: indent)
            .trimmingSingleTrailingNewline()
        return HTML.comment(sanitizeForHtmlComment(rendered))
    }

    /// Builder variant: render multiple nodes, join them, and wrap in a single comment block.
    static func commented(
        options: HTMLRenderOptions = .init(),
        indent: Int = 0,
        @HTMLBuilder _ content: () -> [any HTMLNode]
    ) -> any HTMLNode {
        let joined = content()
            .map { $0.render(options: options, indent: indent) }
            .joined()
            .trimmingSingleTrailingNewline()
        return HTML.comment(sanitizeForHtmlComment(joined))
    }
}

(!): 1 blank lines


+--------------------------------------------------+
| Sources/Constructors/html/funcs/html-comps.swift |
+--------------------------------------------------+
import Foundation

public enum HTML {
    public static func el(
        _ tag: String,
        _ attrs: HTMLAttribute = HTMLAttribute(),
        @HTMLBuilder _ children: () -> [any HTMLNode] = { [] }
    ) -> any HTMLNode {
        HTMLElement(tag, attrs: attrs, children: children())
    }

    public static func document(@HTMLBuilder _ body: () -> [any HTMLNode]) -> HTMLDocument {
        HTMLDocument(children: body())
    }

    public static func html(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("html", attrs, c) }
    public static func head(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("head", attrs, c) }
    public static func body(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("body", attrs, c) }

    // Head primitives
    public static func meta(_ attrs: HTMLAttribute) -> any HTMLNode { el("meta", attrs) }
    public static func title(_ text: String) -> any HTMLNode { HTMLElement("title", children: [HTMLText(text)]) }

    @available(*, deprecated, message: "Use HTML.link(.stylesheet(href:))")
    public static func linkStylesheet(href: String) -> any HTMLNode { el("link", ["rel":"stylesheet","href": href]) }

    public static func stylsheet(href: String) -> any HTMLNode { el("link", ["rel":"stylesheet","href": href]) }

    public static func style(_ css: String) -> any HTMLNode { HTMLElement("style", children: [HTMLRaw(css)]) }

    // Body common
    public static func div(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("div", attrs, c) }
    public static func p(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("p", attrs, c) }
    public static func span(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("span", attrs, c) }
    public static func a(_ href: String, _ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode {
        var merged = attrs; merged.merge(["href": href]); return el("a", merged, c)
    }
    public static func img(src: String, alt: String = "", _ attrs: HTMLAttribute = HTMLAttribute()) -> any HTMLNode {
        var merged = attrs; merged.merge(["src": src, "alt": alt]); return el("img", merged)
    }
    public static func br() -> any HTMLNode { el("br") }
    public static func br(_ n: Int) -> HTMLFragment { Array(repeating: HTML.br(), count: n) }

    public static func hr(_ attrs: HTMLAttribute = HTMLAttribute()) -> any HTMLNode { el("hr", attrs) }

    public static func code(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("code", attrs, c) }
    public static func pre(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("pre", attrs, c) }

    // Lists
    public static func ul(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("ul", attrs, c) }
    public static func ol(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("ol", attrs, c) }
    public static func li(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("li", attrs, c) }

    // Tables
    public static func table(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("table", attrs, c) }
    public static func thead(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("thead", attrs, c) }
    public static func tbody(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("tbody", attrs, c) }
    public static func tr(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("tr", attrs, c) }
    public static func th(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("th", attrs, c) }
    public static func td(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("td", attrs, c) }

    // Text
    public static func text(_ s: String) -> any HTMLNode { HTMLText(s) }
    public static func raw(_ s: String)  -> any HTMLNode { HTMLRaw(s) }

    public static func b(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode {
        el("b", attrs, c)
    }

    public static func i(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode {
        el("i", attrs, c)
    }

    public static func strong(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode {
        el("strong", attrs, c)
    }

    public static func em(_ attrs: HTMLAttribute = HTMLAttribute(), @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode {
        el("em", attrs, c)
    }

    @inlinable
    public static func repeating(_ n: Int, @HTMLBuilder builder: () -> [any HTMLNode]) -> [any HTMLNode] {
        var out: [any HTMLNode] = []
        for _ in 0..<n {
            out.append(contentsOf: builder())
        }
        return out
    }

    public static func `if`(_ condition: Bool, @HTMLBuilder _ content: () -> HTMLFragment) -> HTMLFragment {
        condition ? content() : []
    }

    public static func comment(_ s: String) -> any HTMLNode { HTMLComment(text: s) }

    public static func elSC(_ tag: String, _ attrs: HTMLAttribute = HTMLAttribute()) -> any HTMLNode {
        HTMLElement(tag, attrs: attrs, children: [], selfClosing: true)
    }

    /// Insert `count` line breaks at this point in the output (pretty mode only).
    public static func newline(_ count: Int = 1) -> any HTMLNode { HTMLNewline(count) }

    /// Convenience: adds a *blank line* (i.e., one empty line between blocks).
    /// Use `blank()` between major sections for readability.
    public static func blank() -> any HTMLNode { HTMLNewline(1) }

    public static func header(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("header", a, c) }
    public static func footer(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("footer", a, c) }
    public static func section(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("section", a, c) }
    public static func figure(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("figure", a, c) }
    public static func figcaption(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("figcaption", a, c) }
    public static func blockquote(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("blockquote", a, c) }

    public static func h1(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("h1", a, c) }
    public static func h2(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("h2", a, c) }
    public static func h3(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("h3", a, c) }
    public static func h4(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("h4", a, c) }
    public static func h5(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("h5", a, c) }
    public static func h6(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("h6", a, c) }

    public static func picture(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("picture", a, c) }
    public static func source(_ a: HTMLAttribute = [:]) -> any HTMLNode { el("source", a) }  // void handled centrally
    public static func svg(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("svg", a, c) }
    public static func path(_ a: HTMLAttribute = [:]) -> any HTMLNode { elSC("path", a) }

    public static func form(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("form", a, c) }
    public static func input(_ a: HTMLAttribute = [:]) -> any HTMLNode { el("input", a) }
    public static func label(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("label", a, c) }
    public static func button(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("button", a, c) }
    public static func textarea(_ a: HTMLAttribute = [:], @HTMLBuilder _ c: () -> [any HTMLNode]) -> any HTMLNode { el("textarea", a, c) }

    public static func type(_ value: String) -> HTMLAttribute { ["type": value] }
    public static func name(_ value: String) -> HTMLAttribute { ["name": value] }
    public static func value(_ value: String) -> HTMLAttribute { ["value": value] }
    public static func placeholder(_ value: String) -> HTMLAttribute { ["placeholder": value] }

    // boolean conveniences
    public static func checked(_ enabled: Bool = true) -> HTMLAttribute { .bool("checked", enabled) }
    public static func disabled(_ enabled: Bool = true) -> HTMLAttribute { .bool("disabled", enabled) }
    public static func readonly(_ enabled: Bool = true) -> HTMLAttribute { .bool("readonly", enabled) }
    public static func required(_ enabled: Bool = true) -> HTMLAttribute { .bool("required", enabled) }
}

public extension HTML {
    @inlinable
    static func attrs(_ parts: HTMLAttribute...) -> HTMLAttribute {
        var out = HTMLAttribute()
        for p in parts { out.merge(p) }
        return out
    }
}

public extension HTML {
    static func script(
        src: String,
       defer: Bool = true,
       `async`: Bool = false,
       type: String? = nil,
       integrity: String? = nil,
       crossorigin: String? = nil,
       _ extra: HTMLAttribute = HTMLAttribute()
    ) -> any HTMLNode {
        var a = extra
        a.merge(["src": src])
        if let type { a.merge(["type": type]) }
        if let integrity { a.merge(["integrity": integrity]) }
        if let crossorigin { a.merge(["crossorigin": crossorigin]) }
        if `defer` { a.merge(.bool("defer", true)) }
        if async { a.merge(.bool("async", true)) }
        return el("script", a)
    }

    static func scriptInline(_ js: String, type: String? = nil) -> any HTMLNode {
        let a = type.map { HTMLAttribute(dictionaryLiteral: ("type",$0)) } ?? HTMLAttribute()
        return el("script", a) { [HTML.raw(js)] }
    }

    static func link(_ spec: LinkSpec, _ extra: HTMLAttribute = [:]) -> any HTMLNode {
        var a = spec.attributes()
        a.merge(extra) 
        return el("link", a)
    }

    static func meta(_ spec: MetaSpec, _ extra: HTMLAttribute = [:]) -> any HTMLNode {
        var a = spec.attributes()
        a.merge(extra)
        return el("meta", a)
    }
}

(!): 1 blank lines


+------------------------------------------------------+
| Sources/Constructors/html/funcs/hmlt-meta-spec.swift |
+------------------------------------------------------+
import Foundation

public enum MetaSpec: Sendable {
    case charset(String = "UTF-8")
    case viewport(String = "width=device-width, initial-scale=1.0")
    case robots(String = "index, follow")
    case httpEquiv(equiv: String, content: String)
    case name(name: String, content: String)                 // generic name=...
    case property(property: String, content: String)         // OG, etc. (property=)
    case twitter(name: String, content: String)              // twitter:* as name=...
    case themeColor(String)                                  // <meta name="theme-color" ...>
    case contentLanguage(String)                             // <meta http-equiv="Content-Language" ...>

    public func attributes() -> HTMLAttribute {
        switch self {
        case .charset(let v):
            let a: HTMLAttribute = ["charset": v]
            return a

        case .viewport(let v):
            let a: HTMLAttribute = ["name":"viewport", "content": v]
            return a

        case .robots(let v):
            let a: HTMLAttribute = ["name":"robots", "content": v]
            return a

        case .httpEquiv(let equiv, let content):
            let a: HTMLAttribute = ["http-equiv": equiv, "content": content]
            return a

        case .name(let name, let content):
            let a: HTMLAttribute = ["name": name, "content": content]
            return a

        case .property(let property, let content):
            let a: HTMLAttribute = ["property": property, "content": content]
            return a

        case .twitter(let name, let content):
            let a: HTMLAttribute = ["name": name, "content": content]
            return a

        case .themeColor(let color):
            let a: HTMLAttribute = ["name":"theme-color", "content": color]
            return a

        case .contentLanguage(let lang):
            let a: HTMLAttribute = ["http-equiv":"Content-Language", "content": lang]
            return a
        }
    }
}

(!): 1 blank lines


+------------------------------------------------------+
| Sources/Constructors/html/funcs/html-link-spec.swift |
+------------------------------------------------------+
import Foundation

public enum LinkSpec: Sendable {
    case preconnect(href: String)
    case preloadImage(
            href: String,
            imagesrcset: String? = nil,
            imagesizes: String? = nil,
            media: String? = nil,
            fetchpriority: String? = nil,
            type: String = "image/jpeg",
            as: String = "image"
        )
    case dnsPrefetch(href: String)
    case prefetchDocument(href: String)
    case modulePreload(href: String, crossorigin: String? = nil)
    case stylesheet(href: String)
    case icon(href: String, type: String = "image/x-icon")
    case appleTouchIcon(href: String, sizes: String, alt: String? = nil)
    case canonical(href: String)
    case alternate(hreflang: String, href: String)
    case manifest(href: String)

    public func attributes() -> HTMLAttribute {
        switch self {
        case .preconnect(let href):
            let a: HTMLAttribute = ["rel":"preconnect", "href": href]
            return a

        case .preloadImage(let href, let imagesrcset, let imagesizes, let media, let fetchpriority, let type, let asVal):
            var a: HTMLAttribute = ["rel":"preload", "as": asVal, "type": type, "href": href]
            if let imagesrcset   { a.merge(["imagesrcset": imagesrcset]) }
            if let imagesizes    { a.merge(["imagesizes": imagesizes]) }
            if let media         { a.merge(["media": media]) }
            if let fetchpriority { a.merge(["fetchpriority": fetchpriority]) }
            return a

        case .dnsPrefetch(let href):
            let a: HTMLAttribute = ["rel":"dns-prefetch","href":href]
            return a

        case .prefetchDocument(let href):
            let a: HTMLAttribute = ["rel":"prefetch","href": href, "as": "document"]
            return a 

        case .modulePreload(let href, let co):
            var a: HTMLAttribute = ["rel":"modulepreload","href": href]
            if let co { a.merge(["crossorigin": co]) }
            return a

        case .stylesheet(let href):
            let a: HTMLAttribute = ["rel":"stylesheet", "href": href]
            return a

        case .icon(let href, let type):
            let a: HTMLAttribute = ["rel":"icon", "href": href, "type": type]
            return a

        case .appleTouchIcon(let href, let sizes, let alt):
            var a: HTMLAttribute = ["rel":"apple-touch-icon", "href": href, "sizes": sizes]
            if let alt { a.merge(["alt": alt]) }
            return a

        case .canonical(let href):
            let a: HTMLAttribute = ["rel":"canonical", "href": href]
            return a

        case .alternate(let hreflang, let href):
            let a: HTMLAttribute = ["rel":"alternate", "hreflang": hreflang, "href": href]
            return a

        case .manifest(let href):
            let a: HTMLAttribute = ["rel":"manifest", "href": href]
            return a
        }
    }
}

(!): 1 blank lines


+-----------------------------------------+
| Sources/Constructors/Constructors.swift |
+-----------------------------------------+
// The Swift Programming Language
// https://docs.swift.org/swift-book

(!): 1 blank lines
